import tkinter
from tkinter import Frame
from tkinter import Text
from tkinter import Entry
from tkinter import WORD
from tkinter import INSERT
from tkinter import END
from tkinter import StringVar
from tkinter import Button
from tkinter import Label
from threading import Thread
import glob
from geopy.geocoders import Nominatim
import csv
import subprocess


class Window:
    # create confirmation window
    def __init__(self, key):
        self.window = tkinter.Tk()
        self.window.title('AAOH')
        self.window.lift()
        self.window.attributes('-topmost', True)
        self.window.after_idle(self.window.attributes, '-topmost', False)

        # used for the search function
        self.matches = 0
        self.counter = 1
        self.found_words = []

        screen_width = self.window.winfo_screenwidth()
        screen_height = self.window.winfo_screenheight()
        self.window.geometry(f"{int(screen_width * .75)}x{int(screen_height * .75)}+{0}+{0}")
        self.window.resizable(False, False)

        # left frame holds transcript, right frame has confirmation screen
        main_frame = Frame(self.window)
        main_frame.grid(column=0, row=0, sticky="nswe")

        right_frame = Frame(main_frame)
        right_frame.grid(column=1, row=0, sticky="nswe")

        left_frame = Frame(main_frame)
        left_frame.grid(column=0, row=0, sticky="nswe")

        left_frame_top = Frame(left_frame)
        left_frame_top.grid(column=0, row=0, sticky="nswe")

        left_frame_bot = Frame(left_frame)
        left_frame_bot.grid(column=0, row=1, sticky="nswe")

        # for searching through the transcript
        search_button = Button(left_frame_top, height=1, width=10, text="Search",  command=self.find_text)
        search_button.grid(row=0, column=0)

        self.search_field = Entry(left_frame_top)
        self.search_field.grid(row=0, column=1, sticky="nswe")

        next_button = Button(left_frame_top, height=1, width=5, text="Next", command=self.find_next)
        next_button.grid(row=0, column=2)

        prev_button = Button(left_frame_top, height=1, width=5, text="Prev", command=self.find_prev)
        prev_button.grid(row=0, column=3)

        self.matches_label = Label(left_frame_top)
        self.matches_label.grid(row=0, column=4)

        # interview transcript
        self.interview_text = Text(left_frame_bot, wrap=WORD, width=int(screen_width / 20), height=int(screen_height /22))
        filelist = glob.glob("Input\\*.txt")
        for file in filelist:
            with open(file, 'r', encoding='utf-8') as f:
                self.interview_text.insert(INSERT, f.read())
        self.interview_text.grid(row=0, column=0, sticky="nswe")

        # confirmation request
        output_text = Text(right_frame, width=int(screen_width / 23), height=int(screen_height / 27))
        output_text.grid(row=0, column=0)

        # user confirmation
        input_text = Text(right_frame, width=int(screen_width / 23), height=int(screen_height / 135), background="light blue")
        input_text.grid(row=1, column=0)

        i = 0
        self.button_pressed = StringVar()
        confirm_button = Button(right_frame, height=2, width=20, text="Confirm", command= lambda: self.button_pressed.set(str(++i)))
        confirm_button.grid(row=2, column=0, sticky="nswe")

        self.window.bind('<Return>', self.take_input(i))

        # get location addresses, thread so the user can still interact with the transcript frame
        t1 = Thread(target=geolocate, daemon=True, args=(key, output_text, input_text, confirm_button, self.button_pressed))
        t1.start()

    def run_mainloop(self):
        # run the windows mainloop
        self.window.protocol("WM_DELETE_WINDOW", self.on_closing)
        self.window.mainloop()

    def take_input(self, i):
        self.button_pressed.set(str(++i))

    def on_closing(self):
        # stops the user input field from looking for input
        self.button_pressed.set(str(-1))
        self.window.destroy()

    def find_text(self):
        # when user searches through the transcript
        text = self.search_field.get()
        start = '1.0'
        self.matches = 0
        self.counter = 1
        if text:
            self.clear_tags()
            while 1:
                start = self.interview_text.search(text, start, regexp=True, nocase=True, stopindex=END)
                if not start: break
                last = '%s+%dc' % (start, len(text))
                self.interview_text.tag_add('found', start, last)
                self.found_words.append((start, last))
                self.matches += 1
                start = last
                self.interview_text.tag_config('found', background='light blue')
                self.interview_text.tag_config('next', background='dodger blue')
        if self.matches == 0:
            self.matches_label.config(text="No matches found")
        else:
            self.matches_label.config(text=f"1 of {str(self.matches)}")
            self.interview_text.tag_remove('found', self.found_words[0][0], self.found_words[0][1])
            self.interview_text.tag_add('next', self.found_words[0][0], self.found_words[0][1])
            self.interview_text.see(self.found_words[0][0])

    def find_next(self):
        if self.matches != 0:
            self.add_found_tags()
            if self.counter == len(self.found_words):
                self.counter = 1
            else:
                self.counter += 1
            self.add_next_tags()
            self.matches_label.config(text=f"{self.counter} of {str(self.matches)}")
            self.interview_text.see(self.found_words[self.counter-1][0])

    def find_prev(self):
        if self.matches != 0:
            self.add_found_tags()
            if self.counter == 1:
                self.counter = len(self.found_words)
            else:
                self.counter -= 1
            self.add_next_tags()
            self.matches_label.config(text=f"{self.counter} of {str(self.matches)}")
            self.interview_text.see(self.found_words[self.counter-1][0])

    def add_found_tags(self):
        self.interview_text.tag_remove('next', self.found_words[self.counter - 1][0],
                                       self.found_words[self.counter - 1][1])
        self.interview_text.tag_add('found', self.found_words[self.counter - 1][0],
                                    self.found_words[self.counter - 1][1])

    def add_next_tags(self):
        self.interview_text.tag_remove('found', self.found_words[self.counter - 1][0],
                                       self.found_words[self.counter - 1][1])
        self.interview_text.tag_add('next', self.found_words[self.counter - 1][0],
                                    self.found_words[self.counter - 1][1])

    def clear_tags(self):
        for tag in self.found_words:
            self.interview_text.tag_remove("found", tag[0], tag[1])
            self.interview_text.tag_remove("next", tag[0], tag[1])
        self.found_words.clear()


def geolocate(geo, output, input_text, confirm_button, button_pressed):
    locations_set = set([])  # collection of location names already seen, tries to limit the amount of times the geocoder has to run
    address_set = set([])  # collecetion of lat/lon address already seen, sometimes the same location might go by different names
    lat_long_str = ""  # string of all geographical addresses of locations added

    rows = []
    bounding_box = [34, -102, 25, -80]  # bounding box for determining if a location needs user confirmation
    importance_benchmark = .5  # importance level to determine if the location is worth adding

    # reads the locations names that the NER put in the csv file
    with (open("Output/location_output.csv", 'r') as csvfile):
        csvreader = csv.reader(csvfile)

        for row in csvreader:
            rows.append(row)

        for row in rows:
            for col in row:
                location = ("%10s" % col).strip()
                if location not in locations_set:
                    locations_set.add(location)
                    try:
                        address = geo.geocode(query=location,
                                              exactly_one=False,
                                              limit=5,
                                              addressdetails=True,
                                              country_codes='US',
                                              featuretype='settlement')  # gets location address information
                    except:
                        output.insert(END, "Couldn't find address for: " + location + "\n")

                    if address is not None and address[0].raw['addresstype'] != "state":  # leaves out states
                        if str(address[0].raw['lat']) + '/' + str(address[0].raw['lon']) not in address_set:  # checks if this address has already been seen
                            address_set.add(str(address[0].raw['lat']) + '/' + str(address[0].raw['lon']))  # if not add the address
                            if float(address[0].raw['importance']) >= importance_benchmark:  # checks importance level against benchmark
                                if check_bounds(bounding_box, float(address[0].raw['lat']), float(address[0].raw['lon'])):  # check if the location is in the gulf south
                                    lat_long_str = add_location(str(address[0].raw['lat']), str(address[0].raw['lon']), lat_long_str)  # if so, then add the location automatically
                                    output.insert(END, "\nLocation Found: " + address[0].raw['display_name'] + "\n")
                                    output.see("end")

                                else:  # if location is not in gulf south, look for user confirmation
                                    output.insert(END, "\nFor " + location + ", which location is best?" + "\n")
                                    output.insert(END, str(0) + ": " + "Do not include location" + "\n")
                                    for i in range(len(address)):
                                        output.insert(END, str(i + 1) + ": " + address[i].raw['display_name'] + "\n")
                                    output.insert(END, "Please choose an option: " + "\n")
                                    output.see("end")

                                    while True: #asks for user input
                                        confirm_button.wait_variable(button_pressed)
                                        if button_pressed.get() == "-1":
                                            exit()
                                        confirmation = input_text.get("1.0", END)
                                        input_text.delete('1.0', END)
                                        if(confirmation != ""):
                                            try:
                                                confirmation = int(confirmation)
                                                if confirmation < 0 or confirmation > len(address):
                                                    raise ValueError
                                                else:
                                                    if confirmation != 0:
                                                        output.insert(END, f"Location {confirmation} added" + "\n")
                                                        lat_long_str = add_location(str(address[confirmation - 1].raw['lat']),
                                                                     str(address[confirmation - 1].raw['lon']), lat_long_str)  # adds the location the user chose
                                                    else:
                                                        output.insert(END, "Location ignored" + "\n")
                                                    break

                                            except ValueError:
                                                output.insert(END, "Please choose a valid option" + "\n")

                                            output.see("end")
                                        else:
                                            continue

    output.insert(END, "\nLocations Added! Please check the output file")
    output.see("end")
    lat_long_str = lat_long_str[:-1]
    values_dict = {'Latitude/Longitude': lat_long_str}  # location string added to the dict that defines the csv output
    # gets item description values for omeka
    get_item_values(values_dict)


def check_bounds(bounds, lat, lon):
    # checks if the location is within a given bounding box
    if bounds[0] > lat > bounds[2]:
        if lon < 0:
            if bounds[1] < lon < bounds[3]:
                return True
    else:
        return False


def add_location(address_lat, address_lon, latlong_str):
    # adds locations to the lat long string
    latlong_str += address_lat + '/' + address_lon
    latlong_str += ";"
    return latlong_str


def get_item_values(values_dict):
    # reads the interview transcript to fill the item values for csv import
    filelist = glob.glob("Input\\*.txt")
    for file in filelist:
        reading = open(file, 'r', errors="ignore")
        while True:
            content = reading.readline()
            if content.strip():
                if content.split()[0] == "AAHP":
                    values_dict['Title'] = content.strip()
                elif content.split()[0] == "Interview":
                    values_dict['interviewer'] = content.strip()
                elif content.split()[0] == "Abstract:":
                    values_dict['Description'] = content.strip()
                elif content.split()[0] == "Keywords:":
                    values_dict['Table of Contents'] = content.strip()
                elif content.split()[0] == "For":
                    break
        # writes output to the csv file
        write_to_file(values_dict)


def write_to_file(values_dict):
    # writes the dict values to the csv for csv import to read, and assign item values
    fields = ["Title", "Description", "Table of Contents", "interviewer", "Latitude/Longitude"]

    with open("Output/location_output.csv", 'w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fields)
        writer.writeheader()
        writer.writerow(values_dict)


if __name__ == '__main__':
    # runs the NER
    subprocess.call(['java', '-jar', 'stanford-ner.jar'])

    # Enter into Nominatim
    geolocator = Nominatim(user_agent="AAHP")

    # create the confirmation window
    main_window = Window(geolocator)
    main_window.run_mainloop()
